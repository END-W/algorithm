# 算法基础

## 1.算法概述

### 1.1评估算法优劣的核心指标是什么

#### ①时间复杂度（流程决定）

#### ②额外空间复杂度（流程决定）

#### ③常数项时间（实现细节决定）

### 1.2何为常数时间的操作？

如果一个操作的执行时间不以具体的样本量为转移，每次执行时间都是固定时间。称这样的操作为常数执行的操作。

### 1.3常见的常数时间的操作

- 常见的算数运算（+、-、*、/、%等）
- 常见的为位运算（>>、>>>、<<、|、&、^等）
- 赋值、比较、自增、自减操作等
- 数组寻址操作

总之，执行时间固定的操作都是常数时间的操作。

反之，执行时间不固定的操作，都不是常数时间的操作。

### 1.4如何确定算法流程的总操作数量与样本数量之间的表达式关系？

1. 想象该算法流程所处理的数据状况，要按照最差情况来。
2. 把整个流程彻底拆分成一个个基本操作，保证每个动作都是常数时间的操作。
3. 如果数据量为N，看看基本动作的数量和N是什么关系。

### 1.5如何确定算法流程的时间复杂度？

当完成表达式的建立，只要把最高阶项留下即可。低阶项都去掉，高阶项的系数也去掉。

记为：O(忽略掉系数的最高项)

### 1.6时间复杂度的意义

当我们要处理的样本量很大很大时，我们会发现低阶项是什么不是最重要的；每一项的系数是什么，不是最重要的。真正重要的就是最高项是什么。

这就是时间复杂度的意义，它是衡量算法流程的复杂程度的一种指标，该指标只与数据量有关，与过程之外的优化无关。

### 1.7额外空间复杂度

你要实现一个算法流程，在实现算法流程的过程中，你需要开辟一些空间来支持你的算法流程。

作为输入参数的空间，不算额外空间。

作为输出结果的空间，也不算额外空间。

因为这些都是必要的、和现实目标有关的。所以都不算。

但除此之外，你的流程如果还需要开辟空间才能让你的流程继续下去。这部分空间就是额外空间。如果你的流程只需要开辟有限几个变量，额外空间复杂度就是O(1)。

### 1.8算法流程的常数项

我们会发现，时间复杂度这个指标，是忽略低阶项和所有常数系数的。难道同样时间复杂度的流程，在实际运行时候就一样的好吗?

当然不是。

时间复杂度只是一个很重要的指标而已。如果两个时间复杂度一样的算法，你还要去在时间上拼优劣，就进入到拼常数时间的阶段，简称拼常数项。

### 1.9算法流程的常数项的比拼方式

放弃理论分析，生成随机数据直接测。

为什么不去理论分析?

不是不能纯分析，而是没必要。因为不同常数时间的操作，虽然都是固定时间，但还是有快慢之分的。

比如，位运算的常数时间原小于算术运算的常数时间，这两个运算的常数时间又远小于数组寻址的时间。

所以如果纯理论分析，往往会需要非常多的分析过程。都已经到了具体细节的程度，莫不如交给实验数据好了。

### 面试、比赛、刷题中，一个问题的最优解是什么意思?

一般情况下，认为解决一个问题的算法流程，在时间复杂度的指标上，一定要尽可能的低，先满足了时间复杂度最低这个指标之后，使用最少的空间的算法流程，叫这个问题的最优解。

一般说起最优解都是忽略掉常数项这个因素的，因为这个因素只决定了实现层次的优化和考虑，而和怎么解决整个问题的思想无关。

### 常见的时间复杂度

排名从好到差:

1. O(1)

2. O(logN)

3. O(N)

4. O(N*logN)

5. O(N^2) O(N^3) … O(N^K)

6. O(2^N) O(3^N) … O(K^N)

7. O(N!)

### 认识异或运算

- 异或运算:相同为0，不同为1
- 同或运算:相同以1，不同为0

所以，异或运算就记成无进位相加!

### 异或运算的性质

- O^N == N   N^N == 0
- 异或运算满足交换律和结合率

### 异或运算举例题

#### ①如何不用额外变量交换两个数

``` java
int a = -6;
int b = 1000;

a = a ^ b;
b = a ^ b;
a = a ^ b;
```

#### ②一个数组中有一个数出现了奇数次，其它数出现了偶数次，怎么找到并打印这个数

```java
// arr中，只有一种数，出现奇次数
public static void printOddTimeNum1(int[] arr) {
    int eor = 0;
    for (int i = 0; i < arr.length; i++) {
        eor ^= arr[i];
    }
    System.out.println(eor);
}
```

#### ③怎么把一个int型的数，提取出最右侧的1来

``` java
int eor = 0;
for (int i = 0; i < arr.length; i++) {
    eor ^= arr[i];
}  
// 提取出最右的1
int rightOne = eor & (~eor + 1);
```

#### ④一个数组中有两种数出现了奇数次，其它数出现了偶数次，怎么找出并打印这两种数

``` java
public static void printOddTimesNum2(int[] arr) {
    int eor = 0;
    for (int i = 0; i < arr.length; i++) {
        eor ^= arr[i];
    }
    // eor = a ^ b;
    // eor != 0
    // eor必然有一个位置上是1
    
    // 提取出最右的1
    int rightOne = eor & (~eor + 1);
    // eor'
    int onlyOne = 0;
    for (int i = 0; i < arr.length; i++) {
        if ((arr[i] & rightOne) != 0) {
            onlyOne ^= arr[i];
        }
    }
    System.out.println(onlyOne + " " + (eor ^ onlyOne));
}
```

#### ⑤怎么把一个int型的数，找出它所有的1个数

``` java
public static void bit1counts(int N) {
    int count = 0;
    while(N != 0) {
        int rightOne = N & (~N + 1);
        count++;
        N ^= rightOne;
    }
    return count;
}
```



## 2.排序算法

### 2.1选择排序

过程：

arr[0 ~ N-1]范围上，找到最小值所在的位置，然后把最小值交换到0位置。

arr[1 ~ N-1]范围上，找到最小值所在的位置，然后把最小值交换到1位置。

arr[2 ~ N-1]范围上，找到最小值所在的位置，然后把最小值交换到2位置。

...

arr[N-1 ~ N-1]范围上，找到最小值位置，然后把最小值交换到N-1位置。

估算:

很明显，如果arr长度为N，每一步常数操作的数量，如等差数列一般；所以，总的常数操作数量= a*(N^2)+ b*N + c (a、b、c都是常数)

所以选择排序的时间复杂度为O(N个2)。

``` java
public static void selectionSort(int[] arr) {
        if (arr == null || arr.length < 2) {
            return;
        }
        for (int i = 0; i < arr.length - 1; i++) {
            int minIndex = i;
            for (int j = i + 1; j < arr.length; j++) {
                if (arr[minIndex] > arr[j]) {
                    minIndex = j;
                }
            }
            swap(arr, i, minIndex);
        }
    }

    public static void swap(int[] arr, int i, int j) {
        int tmp = arr[i];
        arr[i] = arr[j];
        arr[j] = tmp;
    }
```

### 2.2冒泡排序

过程：

在arr[0 ~ N-1]范围上:

arr[0]和arr[1]，谁大谁来到1位置; arr[1]和arr[2]，谁大谁来到2位置 … arr[N-2]和arr[N-1]，谁大谁来到N-1位置

在arr[0 ~ N-2]范围上，重复上面的过程，但最后一步是arr[N-3]和arr[N-2]，谁大谁来到N-2位置

在arr[0~N-3]范围上，重复上面的过程，但最后一步是arr(N-4]和arr(N-3j，谁大谁来到N-3位置

…

最后在arr[0~1]范围上，重复上面的过程，但最后一步是arr[0]和arr[1]，谁大谁来到1位置

估算：

很明显，如果arr长度为N，每一步常数操作的数量，依然如等差数列一般；所以，总的常数操作数量= a*(N^2) + b*N + c (a. b、c都是常数)

所以冒泡排序的时间复杂度为O(N^2)。

``` java
public static void bubbleSort(int[] arr) {
        if (arr == null || arr.length < 2) {
            return;
        }
        for (int end = arr.length - 1; end > 0; end--) {
            for (int i = 0; i < end; i++) {
                if (arr[i] > arr[i + 1]) {
                    swap(arr, i, i + 1);
                }
            }
        }
    }

    // 交换arr的i和j位置上的值
    public static void swap(int[] arr, int i, int j) {
        int tmp = arr[i];
        arr[i] = arr[j];
        arr[j] = tmp;
    }
```

### 2.3插入排序

过程：

想让arr[0~0]上有序．这个范围只有一个数.当然是有序的。

想让arr[0~1]上有序．所以从arr[1]开始往前看．如果arr[1]<arr[0]，就交换。否则什么也不做。

...

想让arr[0~i]上有序，所以从arr[i]开始往前看 arr[i]]这个数不停向左移动，一直移动到左边的数字不再比自己大，停止移动。

最后一步，想让arr[0~N-1]上有序, arr[N-1]这个数不停向左移动，一直移动到左边的数字不再比自己大，停止移动。

估算时发现这个算法流程的复杂程度，会因为数据状况的不同而不同。你发现了吗?

如果某个算法流程的复杂程度会根据数据状况的不同而不同，那么你必须要按照最差情况来估计。很明显，在最差情况下，如果arr长度为N,插入排序的每一步常数操作的数量，还是如等差数列一般；所以．总的常数操作数量= a*(N^2)+ bN + c(a、b、c都是常数)

所以插入排序排序的时间复杂度为O(N^2)。

``` java
public static void insertionSort(int[] arr) {
        if (arr == null || arr.length < 2) {
            return;
        }
        // 0 ~ i 做到有序
        for (int i = 1; i < arr.length; i++) {
            for (int j = i - 1; j >= 0 && arr[j] > arr[j + 1]; j--) {
                swap(arr, j, j + 1);
            }
        }
    }

    // i和j,数交换
    public static void swap(int[] arr, int i, int j) {
        int tmp = arr[i];
        arr[i] = arr[j];
        arr[j] = tmp;
    }
```

## 3.查找

### 3.1二分法

1. 在一个有序数组中，找某个数是否存在
2. 在一个有序数组中，找>=某个数最左侧的位置
3. 在一个有序数组中，找<=某个数最右侧的位置
4. 局部最小值问题

#### ①在一个有序数组中，找某个数是否存在

``` java
// arr保证有序
    public static boolean find(int[] arr, int num) {
        if (arr == null || arr.length == 0) {
            return false;
        }
        int L = 0;
        int R = arr.length - 1;
        while (L <= R) {
            int mid = L + ((R - L) >> 1);
            if (arr[mid] == num) {
                return true;
            } else if (arr[mid] > num) {
                R = mid - 1;
            } else {
                L = mid + 1;
            }
        }
        return false;
    }
```

#### ②在一个有序数组中，找>=某个数最左侧的位置

``` java
// arr有序的，>=num 最左
    public static int mostLeftNoLessNumIndex(int[] arr, int num) {
        if (arr == null || arr.length == 0) {
            return -1;
        }
        int L = 0;
        int R = arr.length - 1;
        // 记录最左的记号
        int index = -1;
        while (L <= R) {
            int mid = L + ((R - L) >> 1);
            if (arr[mid] >= num) {
                index = mid;
                R = mid - 1;
            } else {
                L = mid + 1;
            }
        }
        return index;
    }
```

#### ③在一个有序数组中，找<=某个数最右侧的位置；同②一样的原理

#### ④局部最小值问题

``` java
// arr 相邻的数不相等！
    public static int getLessIndex(int[] arr) {
        if (arr == null || arr.length == 0) {
            return -1;
        }
        if (arr.length == 1 || arr[0] < arr[1]) {
            return 0;
        }
        if (arr[arr.length - 1] < arr[arr.length - 2]) {
            return arr.length - 1;
        }
        int L = 1;
        int R = arr.length - 2;
        int mid = 0;
        while (L < R) {
            mid = L + ((R - L) >> 1);
            if (arr[mid] > arr[mid - 1]) {
                R = mid - 1;
            } else if (arr[mid] > arr[mid + 1]) {
                L = mid + 1;
            } else {
                return mid;
            }
        }
        return L;
    }
```



